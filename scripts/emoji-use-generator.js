#!/usr/bin/env node

/**
 * Repo Emoji Use Generator
 *
 * Scans all code files for emojis and generates EMOJIS_IN_REPO.md
 * Usage: node scripts/emoji-use-generator.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.join(__dirname, '..');

// Matches most Unicode emojis
const EMOJI_REGEX =
    /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]|[\u{FE00}-\u{FE0F}]|[\u{1F004}]|[\u{1F0CF}]|[\u{1F170}-\u{1F251}]/gu;

const SCAN_EXTENSIONS = ['.js', '.ts', '.svelte', '.json'];

const IGNORE_DIRS = [
    'node_modules',
    '.git',
    'dist',
    'build',
    '.svelte-kit',
    '.vscode',
    '.mongodb-data',
];

const IGNORE_FILES = ['emoji-use-generator.js'];

/**
 * Recursively get all files in a directory
 */
function getAllFiles(dirPath, arrayOfFiles = []) {
    const files = fs.readdirSync(dirPath);

    files.forEach((file) => {
        const fullPath = path.join(dirPath, file);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
            if (!IGNORE_DIRS.includes(file)) {
                arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);
            }
        } else {
            const ext = path.extname(file);
            if (SCAN_EXTENSIONS.includes(ext) && !IGNORE_FILES.includes(file)) {
                arrayOfFiles.push(fullPath);
            }
        }
    });

    return arrayOfFiles;
}

function extractEmojisFromFile(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n');
        const findings = [];

        lines.forEach((line, lineNumber) => {
            const matches = [...line.matchAll(EMOJI_REGEX)];

            matches.forEach((match) => {
                const emoji = match[0];
                const context = line.trim();
                const relativeFilePath = path.relative(projectRoot, filePath);

                findings.push({
                    emoji,
                    file: relativeFilePath,
                    line: lineNumber + 1,
                    context:
                        context.length > 80
                            ? context.substring(0, 77) + '...'
                            : context,
                });
            });
        });

        return findings;
    } catch (error) {
        console.warn(
            `Warning: Could not read file ${filePath}: ${error.message}`,
        );
        return [];
    }
}

/**
 * Get unique emojis and sort by usage frequency
 */
function processFindings(allFindings) {
    const emojiMap = new Map();

    allFindings.forEach((finding) => {
        const key = finding.emoji;
        if (!emojiMap.has(key)) {
            emojiMap.set(key, {
                emoji: finding.emoji,
                count: 0,
                usages: [],
            });
        }

        const entry = emojiMap.get(key);
        entry.count++;
        entry.usages.push({
            file: finding.file,
            line: finding.line,
            context: finding.context,
        });
    });

    // Sort by frequency (most used first), then alphabetically
    return Array.from(emojiMap.values()).sort((a, b) => {
        if (b.count !== a.count) {
            return b.count - a.count;
        }
        return a.emoji.localeCompare(b.emoji);
    });
}

function generateMarkdown(processedEmojis) {
    const now = new Date().toISOString().split('T')[0];

    let markdown = `# 🎨 Emoji Use in Repo (Auto-Generated)

*Last updated: ${now}*

This document catalogs all emojis currently used in the Jurnl codebase. It's automatically generated by scanning all source files.

## 📊 Summary

- **Total unique emojis**: ${processedEmojis.length}
- **Total usage count**: ${processedEmojis.reduce((sum, emoji) => sum + emoji.count, 0)}
- **Most used emoji**: ${processedEmojis[0]?.emoji || 'N/A'} (${processedEmojis[0]?.count || 0} times)

## 📋 Emoji Usage Table

| Emoji | Count | File Path | Context |
|-------|-------|-----------|---------|
`;

    processedEmojis.forEach((emojiData) => {
        emojiData.usages.forEach((usage, index) => {
            const emoji = index === 0 ? emojiData.emoji : '';
            const count = index === 0 ? emojiData.count : '';

            markdown += `| ${emoji} | ${count} | \`${usage.file}:${usage.line}\` | ${usage.context} |\n`;
        });
    });

    markdown += `
## 🔍 Usage by Category

### Most Frequently Used (5+)
${
    processedEmojis
        .filter((e) => e.count >= 5)
        .map((e) => `- ${e.emoji} (${e.count}x)`)
        .join('\n') || '*(None)*'
}

### Moderately Used (2-4)
${
    processedEmojis
        .filter((e) => e.count >= 2 && e.count < 5)
        .map((e) => `- ${e.emoji} (${e.count}x)`)
        .join('\n') || '*(None)*'
}

### Single Use
${
    processedEmojis
        .filter((e) => e.count === 1)
        .map((e) => `- ${e.emoji}`)
        .join(' ') || '*(None)*'
}

## 🛠️ Maintenance

This file is automatically generated. To update it, run:

\`\`\`bash
node scripts/generate-emoji-reference.js
\`\`\`

### Files Scanned
- Extensions: ${SCAN_EXTENSIONS.join(', ')}
- Ignored directories: ${IGNORE_DIRS.join(', ')}
- Ignored files: ${IGNORE_FILES.join(', ')}

### Last Scan Results
- Files processed: *Will be updated during generation*
- Scan completed: ${new Date().toISOString()}

---

**Note**: This is an automatically generated file. Manual edits will be overwritten.
`;

    return markdown;
}

function main() {
    console.log('🔍 Scanning for emojis in project files...');

    const allFiles = getAllFiles(projectRoot);
    const validFiles = allFiles.filter((file) => {
        const ext = path.extname(file);
        return SCAN_EXTENSIONS.includes(ext);
    });

    console.log(`📁 Found ${validFiles.length} files to scan`);

    let allFindings = [];
    let processedFiles = 0;

    validFiles.forEach((file) => {
        const findings = extractEmojisFromFile(file);
        allFindings = allFindings.concat(findings);
        processedFiles++;

        if (findings.length > 0) {
            console.log(
                `  ✨ ${path.relative(projectRoot, file)}: ${findings.length} emoji(s)`,
            );
        }
    });

    console.log(`\n📊 Processing ${allFindings.length} emoji occurrences...`);

    const processedEmojis = processFindings(allFindings);

    console.log(`🎯 Found ${processedEmojis.length} unique emojis`);

    const markdown = generateMarkdown(processedEmojis);

    const finalMarkdown = markdown.replace(
        'Files processed: *Will be updated during generation*',
        `Files processed: ${processedFiles}`,
    );

    const outputPath = path.join(projectRoot, 'EMOJI_REFERENCE.md');
    fs.writeFileSync(outputPath, finalMarkdown, 'utf8');

    console.log(`\n✅ Generated EMOJI_REFERENCE.md`);
    console.log(`📍 Location: ${outputPath}`);
    console.log(
        `📈 Summary: ${processedEmojis.length} unique emojis from ${allFindings.length} occurrences`,
    );

    if (processedEmojis.length > 0) {
        console.log('\n🏆 Top 5 Most Used Emojis:');
        processedEmojis.slice(0, 5).forEach((emoji, index) => {
            console.log(`  ${index + 1}. ${emoji.emoji} (${emoji.count}x)`);
        });
    }
}

if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}

export { main, extractEmojisFromFile, processFindings, generateMarkdown };
